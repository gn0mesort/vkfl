/**
 * @file vkfl.cpp
 * @author Alexander Rothman <gnomesort@megate.ch>
 * @date December 27, 2021
 * @copyright LGPL-3.0
 * @brief Dynamic Vulkan function pointer loader implementation.
 */

#include "vkfl.hpp"

@private_defines@

namespace vkfl {
  void loader::load_instance_fns(const VkInstance context) {
    constexpr auto idx = static_cast<std::size_t>(command::GetInstanceProcAddr);
    const auto context_loader = reinterpret_cast<get_instance_proc_addr_fn>(m_pfns[idx]);
@load_instance@
  }

  void loader::load_device_fns(const VkInstance context) {
    constexpr auto idx = static_cast<std::size_t>(command::GetInstanceProcAddr);
    const auto context_loader = reinterpret_cast<get_instance_proc_addr_fn>(m_pfns[idx]);
@load_device@
  }

  void loader::load_device_fns(const VkDevice context) {
    constexpr auto idx = static_cast<std::size_t>(command::GetDeviceProcAddr);
    const auto context_loader = reinterpret_cast<get_device_proc_addr_fn>(m_pfns[idx]);
@load_device@
  }

  loader::loader(const get_instance_proc_addr_fn global) {
    if (!global)
    {
      throw error{ "The global loader function must not be null." };
    }
    const auto context_loader = global;
    const auto context = nullptr;
@load_global@
    constexpr auto idx = static_cast<std::size_t>(command::GetInstanceProcAddr);
    m_pfns[idx] = reinterpret_cast<any_fn>(global);
  }

  loader::any_fn loader::get(const command cmd) const {
    return m_pfns[static_cast<std::size_t>(cmd)];
  }

  loader::any_fn loader::operator()(const command cmd) const {
    return get(cmd);
  }

  loader& loader::load(const VkInstance context) {
    if (!context)
    {
      throw error{ "The instance handle must not be null." };
    }
    load_instance_fns(context);
    load_device_fns(context);
    m_loaded_instance = context;
    m_loaded_device = nullptr;
    return *this;
  }

  loader& loader::load(const VkDevice context) {
    if (!context)
    {
      throw error{ "The device handle must not be null." };
    }
    if (!m_loaded_instance)
    {
      throw error{ "A matching instance must be loaded before loading a device." };
    }
    load_device_fns(context);
    m_loaded_device = context;
    return *this;
  }

  VkInstance loader::loaded_instance() const {
    return m_loaded_instance;
  }

  VkDevice loader::loaded_device() const {
    return m_loaded_device;
  }

  loader& loader::unload_device() {
    if (m_loaded_device)
    {
      load_device_fns(m_loaded_instance);
      m_loaded_device = nullptr;
    }
    return *this;
  }

  loader& loader::unload_instance() {
    if (m_loaded_instance)
    {
      for (auto i = std::size_t{ VKFL_GLOBAL_MAX }; i < std::size(m_pfns); ++i)
      {
        m_pfns[i] = nullptr;
      }
      m_loaded_device = nullptr;
      m_loaded_instance = nullptr;
    }
    return *this;
  }

}
