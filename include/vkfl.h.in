#ifndef VKFL_H
#define VKFL_H
/**
 * @file vkfl.h
 * @author Alexander Rothman <gnomesort@megate.ch>
 * @date June, 10 2022
 * @copyright Apache-2.0
 * @brief Dynamic Vulkan function pointer loader.
 *
 * Copyright 2022 Alexander Rothman
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <inttypes.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

#define VKFL_DEFINE_HANDLE(object) \
  struct object##_T; \
  typedef struct object##_T* object

VKFL_DEFINE_HANDLE(VkInstance);
VKFL_DEFINE_HANDLE(VkDevice);

#if defined(_WIN32)
  #define VKFLAPI_ATTR_PRIV
  #define VKFLAPI_CALL_PRIV __stdcall
  #define VKFLAPI_PTR_PRIV VKFLAPI_CALL
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
  #error "Vulkan is not supported for the 'armeabi' NDK ABI"
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && defined(__ARM_32BIT_STATE)
  #define VKFLAPI_ATTR_PRIV __attribute__((pcs("aapcs-vfp")))
  #define VKFLAPI_CALL_PRIV
  #define VKFLAPI_PTR_PRIV VKFLAPI_ATTR
#else
  #define VKFLAPI_ATTR_PRIV
  #define VKFLAPI_CALL_PRIV
  #define VKFLAPI_PTR_PRIV
#endif

#ifndef VKFLAPI_CALL
  #define VKFLAPI_CALL VKFLAPI_CALL_PRIV
#endif

#ifndef VKFLAPI_ATTR
  #define VKFLAPI_ATTR VKFLAPI_ATTR_PRIV
#endif

#ifndef VKFLAPI_PTR
  #define VKFLAPI_PTR VKFLAPI_PTR_PRIV
#endif

% for api in enabled_apis:
#define VKFL_API_${api.replace(".", "_")}_ENABLED 1
% endfor
% if generate_disabled_defines:
% for api in disabled_apis:
#define VKFL_API_${api.replace(".", "_")}_ENABLED 0
% endfor
% endif
% for extension in enabled_extensions:
#define ${extension.replace("VK", "VKFL").upper()}_ENABLED 1
% endfor
% if generate_disabled_defines:
% for extension in disabled_extensions:
#define ${extension.replace("VK", "VKFL").upper()}_ENABLED 0
% endfor
% endif
#define VKFL_BUILD_DATE ${f"{buildtime.year}{buildtime.month:02}{buildtime.day:02}"}ULL
#define VKFL_BUILD_TIME ${f"{buildtime.hour}{buildtime.minute:02}{buildtime.second:02}"}ULL

/**
 * @brief Constants used by vkfl.
 */
enum vkfl_constant {
  /**
   * @brief The Vulkan header version from which this file was generated.
   */
  VKFL_HEADER_VERSION = ${spec_version},
  /**
   * @brief The total number of commands in vkfl_command.
   */
  VKFL_COMMAND_COUNT = ${len(enabled_global_commands) + len(enabled_instance_commands) + len(enabled_device_commands)}
};

/**
 * @brief An enumeration of all supported Vulkan commands.
 */
enum vkfl_command {
  @c_commands@
  % for command in enabled_global_commands:
  VKFL_COMMAND_${command},
  % endfor
  % for command in enabled_instance_commands:
  VKFL_COMMAND_${command},
  % endfor
  % for command in enabled_device_commands:
  VKFL_COMMAND_${command},
  % endfor
};

/**
 * @brief An enumeration of results returned from vkfl functions.
 */
enum vkfl_result {
  /**
   * @brief An error generated by passing a null global loader function (i.e. vkGetInstanceProcAddr) pointer to
   * vkfl_create_loader().
   */
  VKFL_ERROR_GLOBAL_LOADER_FN_IS_NULL = -1,
  /**
   * @brief An error generated by passing a null VkInstance to vkfl_load_instance().
   */
  VKFL_ERROR_INSTANCE_IS_NULL = -2,
  /**
   * @brief An error generated by passing a null VkDevice to vkfl_load_device().
   */
  VKFL_ERROR_DEVICE_IS_NULL = -3,
  /**
   * @brief An error generated by attempting to call vkfl_load_device() before a valid VkInstance has been loaded.
   */
  VKFL_ERROR_BAD_LOAD_ORDER = -4,
  /**
   * @brief A result indicating a vkfl operation succeeded.
   */
  VKFL_SUCCESS = 0,
  /**
   * @brief A result indication that no vkfl operation actually occurred as a result of a function call.
   *
   * This is returned in various cases to indicate that loading/unloading a VkDevice/VkInstance was meaningless.
   */
  VKFL_NOOP = 1
};

typedef void (VKFLAPI_PTR *vkfl_any_fn)(void);
typedef vkfl_any_fn (VKFLAPI_PTR *vkfl_get_instance_proc_addr_fn)(VkInstance, const char*);
typedef vkfl_any_fn (VKFLAPI_PTR *vkfl_get_device_proc_addr_fn)(VkDevice, const char*);
typedef void* (*vkfl_allocation_fn)(const size_t);
typedef void (*vkfl_deallocation_fn)(void *const);

/**
 * @brief Vulkan function pointer loader.
 *
 * The loader is fairly simple in concept. Function pointers are loaded in three stages. First, when a new loader is
 * created globally available function pointers are loaded. Second, when `vkfl_load_instance()` is called instance
 * level function pointers are loaded. Third, when `vkfl_load_device()` is called device level function pointers are
 * loaded. During instance level loading the instance level copies of device level function pointers are loaded as
 * well.
 *
 * Note that this loader does not have functionality to dynamically link libvulkan. The initial global loader
 * function pointer must be resolved some other way.
 *
 * Also note that this loader does not take ownership of `VkInstance` or `VkDevice` handles passed to it. If either
 * the instance of device are destroyed before the loader these may no longer be valid handles.
 */
struct vkfl_loader;

/**
 * @brief Allocation callbacks used for creating and destroying vkfl_loaders.
 */
struct vkfl_allocation_callbacks {
  vkfl_allocation_fn allocator;
  vkfl_deallocation_fn deallocator;
};

/**
 * @brief Constructs a new `vkfl_loader` object and loads the global Vulkan function pointers.
 *
 * The function pointer passed to this function only needs the correct signature. It doesn't matter whether it
 * is a pointer to a static `vkGetInstanceProcAddr` function, the result of a call to `dlsym`, or something else.
 * It is an error to construct a `vkfl_loader` with a null loader function pointer.
 *
 * @param global A pointer to a valid Vulkan instance loader function. Must not be NULL.
 * @param alloc A pointer to allocation callbacks. This can be NULL, in which case `malloc()` is used.
 * @returns A pointer to a new `vkfl_loader` on success. NULL is returned if there is an error.
 */
struct vkfl_loader* vkfl_create_loader(const vkfl_get_instance_proc_addr_fn global,
                                       const struct vkfl_allocation_callbacks *const alloc);


/**
 * @brief Destroys a `vkfl_loader`.
 *
 * @param dl The `vkfl_loader` to destroy. This can be NULL, in which case the function returns immediately.
 * @param alloc A pointer to allocation callbacks. This can be NULL, in which case `free()` is used.
 */
void vkfl_destroy_loader(struct vkfl_loader *const dl, const struct vkfl_allocation_callbacks *const alloc);

/**
 * @brief copies a `vkfl_loader` as if by memcpy.
 *
 * A copied loader will be in the same state as the input loader and share any loaded function pointers as well as
 * stored VkInstance/VkDevice handles.
 *
 * @param dl The `vkfl_loader` to copy. Must not be NULL.
 * @param alloc A pointer to allocation callbacks. This can be NULL, in which case `malloc()` is used.
 * @returns A new `vkfl_loader` in the same state as `dl` on success. NULL is returned if there is an error.
 */
struct vkfl_loader* vkfl_copy_loader(const struct vkfl_loader *const dl,
                                     const struct vkfl_allocation_callbacks* const alloc);

/**
 * @brief Load instance level function pointers.
 *
 * This method will load instance level pointers for both instance and device commands.
 *
 * Note that calling this method after loading device level pointers will overwrite those pointers with their
 * instance level equivalents.
 *
 * @param dl The `vkfl_loader` to load instance level functions into. This can be NULL, in which case the function
 * immediately returns.
 * @param context A Vulkan instance from which instance level pointers can be loaded. This must not be NULL.
 * @returns VKFL_SUCCESS on success. VKFL_NOOP if dl is NULL. VKFL_ERROR_INSTANCE_IS_NULL if `context` is NULL.
 */
enum vkfl_result vkfl_load_instance(struct vkfl_loader *const dl, const VkInstance context);

/**
 * @brief Load device level function pointers.
 *
 * @param dl The `vkfl_loader` to load device level functions into. This can be NULL, in which case the function
 * immediately returns.
 * @param context A Vulkan device from which device level pointers can be loaded.
 * @returns VKFL_SUCCESS on success. VKFL_NOOP if dl is NULL. VKFL_ERROR_DEVICE_IS_NULL if `context` is NULL.
 * VKFL_ERROR_BAD_LOAD_ORDER if this function was called before loading a valid VkInstance.
 */
enum vkfl_result vkfl_load_device(struct vkfl_loader *const dl, const VkDevice context);

/**
 * @brief Unload device level function pointers.
 *
 * This will reload the instance level equivalents of all device level pointers. Therefore this is equivalent to:
 *
 * `vkfl_load_instance(ld, vkfl_loaded_instance(ld))`
 *
 * @param dl The `vkfl_loader` to reset to instance level functionality. This can be NULL, in which case the function
 * immediately returns.
 * @returns VKFL_SUCCESS on success. VKFL_NOOP if no device was loaded or if dl is NULL.
 */
enum vkfl_result vkfl_unload_device(struct vkfl_loader *const dl);

/**
 * @brief Unload instance level function pointers.
 *
 * As it is impossible to have a valid `VkDevice` without a corresponding instance this will clear any device level
 * functionality as well. Essentially, this method reverts the loader to the state it was in immediately after
 * construction.
 *
 * @param dl The `vkfl_loader` to reset to global level functionality. This can be NULL, in which case the function
 * immediately returns.
 * @returns VKFL_SUCCESS on success. VKFL_NOOP if no instance was loaded or if dl is NULL>
 */
enum vkfl_result vkfl_unload_instance(struct vkfl_loader *const dl);

/**
 * @brief Get the `VkInstance` handle of the currently loaded instance.
 *
 * @param dl The `vkfl_loader` to retrieve the loaded `VkInstance` from. This can be NULL.
 * @returns The currently loaded `VkInstance`. If dl is NULL or does not have a loaded `VkInstance` a null handle is
 * returned instead.
 */
VkInstance vkfl_loaded_instance(const struct vkfl_loader *const dl);

/**
 * @brief Get the `VkDevice` handle of the currently loaded device.
 *
 * @param dl The `vkfl_loader` to retrieve the loaded `VkDevice` from. This can be NULL.
 * @returns The currently loaded `VkDevice`. If dl is NULL or does not have a loaded `VkDevice` a null handle is
 * returned instead.
 */
VkDevice vkfl_loaded_device(const struct vkfl_loader *const dl);

/**
 * @brief Resolve a Vulkan command into a function pointer.
 *
 * Note that the results of this method are ambiguous function pointers (i.e. pointers of the type `vkfl_any_fn`
 * which itself is equivalent to `PFN_vkVoidFunction`). Before using the pointers returned by this method they must
 * be cast to the correct type.
 *
 * Additionally, no attempt is made to check for null pointers. A pointer may be null either because it has not
 * been loaded or because it is part of an extension that isn't enabled/available.
 *
 * @param dl The `vkfl_loader` to retrieve function pointers from. This can be NULL, in which case the result is always
 * NULL.
 * @param cmd The Vulkan command to retrieve a function pointer for.
 * @returns A pointer to the desired Vulkan command function or NULL.
 */
vkfl_any_fn vkfl_get(const struct vkfl_loader *const dl, const enum vkfl_command cmd);

#ifdef __cplusplus
}
#endif

#endif
